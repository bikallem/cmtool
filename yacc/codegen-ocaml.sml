
structure CodegenOcaml
   :> CODEGEN
   =
   struct

      structure S = SymbolSet
      structure D = SymbolDict

      open CodegenUtil
      open Automaton




      fun labelToString l =
         (case l of
             Syntax.IdentLabel s =>
                Symbol.toValue s
           | Syntax.NumericLabel n =>
                Int.toString n)


      fun isUnit dom = List.null dom

      fun isSolearg dom =
         (case dom of
             [(Syntax.NumericLabel _, _)] => true
           | _ => false)

      fun isTuple dom =
         (case dom of
             (Syntax.NumericLabel _, _) :: _ :: _ => true
           | _ => false)


      (* Converts a word to a big-endian byte list. *)
      fun wordToBytelist w acc =
         if w = 0w0 then
            acc
         else
            let
               val lo = Word.andb (w, 0wxff)
               val hi = Word.>> (w, 0w8)
            in
               wordToBytelist hi (lo :: acc)
            end

      fun duplicateOnto n x acc =
         if n = 0 then
             acc
         else
            duplicateOnto (n-1) x (x :: acc)

      (* intToBytes size n

         if    0 <= n < 2^(8 * size)
         then  l is a big-endian byte list representing n
               |l| = stateSize
               and 
               return l
      *)
      fun intToBytes size n =
         let
            val l = 
               wordToBytelist (Word.fromInt n) []
         in
            duplicateOnto (size - length l) 0w0 l
         end


      fun byteToString b =
         if b < 0w16 then
            "\\x0" ^ Word.toString b
         else if b < 0w32 orelse b > 0w126 then
            "\\x" ^ Word.toString b
         else if b = 0w39 then
            "\\'"
         else if b = 0w34 then
            "\\\""
         else if b = 0w134 then
            "\\\\"
         else
            String.str (Char.chr (Word.toInt b))


      fun writeTableEntry write stateSize adjust entry =
         app
            (fn b => write (byteToString b))
            (intToBytes stateSize (entry + adjust))



      fun writeProgram outfile (options, types, terminals, nonterminals, actions, automaton as (stateCount, states, rules, start)) =
         let
            val functorName =
               (case StringDict.find options "name" of
                   SOME name => name
                 | NONE =>
                      (
                      print "Error: no functor name specified.\n";
                      raise Error
                      ))

            val (terminalOrdinals, terminalCount) =
               D.foldl
               (fn (terminal, _, (ordinals, count)) =>
                   (D.insert ordinals terminal count,
                    count+1))
               (D.singleton (Symbol.fromValue "$") 0, 1)
               terminals

            val (nonterminalOrdinals, nonterminalCount) =
               D.foldl
               (fn (nonterminal, _, (ordinals, count)) =>
                   (D.insert ordinals nonterminal count,
                    count+1))
               (D.empty, 0)
               nonterminals

            val minorLimit = Int.max (terminalCount, nonterminalCount)
            val (minorLimit', minorSize) =
               if minorLimit <= 32 then
                  (32, "5")
               else if minorLimit <= 64 then
                  (64, "6")
               else if minorLimit <= 128 then
                  (128, "7")
               else if minorLimit <= 256 then
                  (256, "8")
               else if minorLimit <= 512 then
                  (512, "9")
               else if minorLimit = D.size terminals then
                  (
                  print "Error: too many terminals.\n";
                  raise Error
                  )
               else
                  (
                  print "Error: too many nonterminals.\n";
                  raise Error
                  )

            val majorLimit =
               Int.max (stateCount, Vector.length rules + 1)
                  
            val (majorSize, adjust) =
               if majorLimit <= 127 then
                  (1, 128)
               else if majorLimit <= 32767 then
                  (2, 32768)
               else if majorLimit = stateCount then
                  (
                  print "Error: too many states.\n";
                  raise Error
                  )
               else
                  (
                  print "Error: too many rules.\n";
                  raise Error
                  )

            val outs = TextIO.openOut outfile
            fun write str = TextIO.output (outs, str)
         in
            write "(* File generated by CM-Yacc version ";
            write Version.version;
            write " *)\n\nmodule ";
            write functorName;
            write "\n   (Strm : Streamable.S)\n   (Arg :\n       sig\n";

            S.app
               (fn tp =>
                   (
                   write "          type ";
                   write (Symbol.toValue tp);
                   write "\n"
                   ))
               types;

            write "\n";

            app
               (fn (actionName, dom, cod) =>
                   let
                      val dom' =
                         Mergesort.sort
                         (fn ((Syntax.NumericLabel n, _), (Syntax.NumericLabel n', _)) => Int.compare (n, n')
                           | _ =>
                                (* Ident labels aren't permitted for Ocaml. *)
                                raise (Fail "invariant"))
                         dom
                   in
                      write "          val ";
                      write (Symbol.toValue actionName);
                      write " : ";
   
                      (* By construction, we have a complete, no-duplicate sequence from 1 to some n. *)
                      app
                         (fn (_, tp) =>
                             (
                             write (Symbol.toValue tp);
                             write " -> "
                             ))
                         dom';
   
                      write (Symbol.toValue cod);
                      write "\n"
                   end)
               actions;

            write "\n          type terminal =\n";
            D.foldl
               (fn (symbol, (tpo, _, _), first) =>
                      (
                      write "           ";
                      if first then
                         write "  "
                      else
                         write "| ";
                      write (Symbol.toValue symbol);
                      (case tpo of
                          NONE => ()
                        | SOME tp =>
                             (
                             write " of ";
                             write (Symbol.toValue tp)
                             ));
                      write "\n";
                      false
                      ))
               true
               terminals;

            write "\n          val error : terminal Strm.t -> exn\n       end)\n   :\n   sig\n      val parse : Arg.terminal Strm.t -> Arg.";
            write (Symbol.toValue (#2 (D.lookup nonterminals start)));
            write " * Arg.terminal Strm.t\n   end\n=\n\n";

            write "(*\n\n";
            WriteAutomaton.writeAutomaton outs automaton;
            write "\n*)\n\n";

            write "struct\nmodule Value = struct\ntype nonterminal =\nEmpty\n";

            S.app
               (fn tp =>
                   (
                   write "| N";
                   write (Symbol.toValue tp);
                   write " of Arg.";
                   write (Symbol.toValue tp);
                   write "\n"
                   ))
               types;

            write "end\nmodule Engine = ParseEngine.Make (struct\nmodule Strm = Strm\ntype terminal = Arg.terminal\ntype value = Value.nonterminal\nlet dummy = Value.Empty\nlet read terminal =\n(match terminal with\n";

            D.foldl
               (fn (terminal, (tpo, _, _), first) =>
                   (
                   if first then
                      ()
                   else
                      write "| ";
                   (case tpo of
                       NONE =>
                          (
                          write "Arg.";
                          write (Symbol.toValue terminal);
                          write " -> (";
                          write (Int.toString (D.lookup terminalOrdinals terminal));
                          write ", Value.Empty)\n"
                          )
                     | SOME tp =>
                          (
                          write "Arg.";
                          write (Symbol.toValue terminal);
                          write " x -> (";
                          write (Int.toString (D.lookup terminalOrdinals terminal));
                          write ", Value.N";
                          write (Symbol.toValue tp);
                          write " x)\n"
                          ));
                   false
                   ))
            true
            terminals;

            write ")\nend)\nlet parse = Engine.parse (\nEngine.next";
            write minorSize;
            write "x";
            write (Int.toString majorSize);
            write " \"";

            app
               (fn (d, _, _) =>
                   let
                      val arr =
                         (* initialize with 0, which represents error *)
                         Array.array (minorLimit', 0)
                   in
                      D.app
                         (fn (terminal, (Shift n :: _, _)) =>
                                Array.update (arr, D.lookup terminalOrdinals terminal, n+1)
                           | (terminal, (Reduce n :: _, _)) =>
                                (* When n = ~1, this is the accept action. *)
                                Array.update (arr, D.lookup terminalOrdinals terminal, ~(n+2))
                           | _ =>
                                raise (Fail "invariant"))
                         d;

                      Array.app (writeTableEntry write majorSize adjust) arr
                   end)
               states;

            write "\",\nEngine.next";
            write minorSize;
            write "x";
            write (Int.toString majorSize);
            write " \"";

            app
               (fn (_, d, _) =>
                   let
                      val arr =
                         Array.array (minorLimit', 0)
                   in
                      D.app
                         (fn (nonterminal, n) =>
                             Array.update (arr, D.lookup nonterminalOrdinals nonterminal, n))
                         d;

                      Array.app (writeTableEntry write majorSize adjust) arr
                   end)
               states;

            write "\",\nArray.of_list [";

            Vector.foldl
               (fn ((rulenum, _, lhs, rhs, args, solearg, action, _, _), first) =>
                   (
                   if first then
                      ()
                   else
                      write ";\n";
                   write "(";
                   write (Int.toString (D.lookup nonterminalOrdinals lhs));
                   write ",";
                   write (Int.toString (length rhs));
                   write ",(function ";

                   let
                      val len =
                         ListPair.foldrEq
                            (fn (_, NONE, n) =>
                                   (
                                   write "_::";
                                   n
                                   )
                              | (symbol, SOME label, n) =>
                                   let
                                      val tp =
                                         (case D.find nonterminals symbol of
                                             SOME (_, tp, _) => tp
                                           | NONE =>
                                                valOf (#1 (D.lookup terminals symbol)))
                                   in
                                      write "Value.N";
                                      write (Symbol.toValue tp);
                                      write "(arg";
                                      write (Int.toString n);
                                      write ")::";
                                      n+1
                                   end)
                            0
                            (rhs, args)

                      val permutation = Array.array (len, ~1)
                   in
                         write "rest -> Value.N";
                         write (Symbol.toValue (#2 (D.lookup nonterminals lhs)));
                         write "(Arg.";
                         write (Symbol.toValue action);
                         
                         (* By construction, args is a complete, no-duplicate sequence from 1 to some n. *)
                         foldr
                            (fn (NONE, n) => n
                              | (SOME (Syntax.NumericLabel i), n) =>
                                   (
                                   Array.update (permutation, i-1, n);
                                   n+1
                                   )
                              | (SOME (Syntax.IdentLabel _), _) =>
                                   (* Not allowed in OCaml. *)
                                   raise (Fail "invariant"))
                            0
                            args;
                         
                         Array.app
                            (fn n =>
                                (
                                write " arg";
                                write (Int.toString n)
                                ))
                            permutation
                   end;
         
                   write ")::rest";
                   if List.null rhs then
                      ()
                   else
                      write "|_->raise (Failure \"bad parser\")";
                   write "))";
                   false
                   ))
               true
               rules;

            write "],\n(function Value.N";
            write (Symbol.toValue (#2 (D.lookup nonterminals start)));
            write " x -> x | _ -> raise (Failure \"bad parser\")), Arg.error)\nend\n";

            TextIO.closeOut outs
         end

   end
